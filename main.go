package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	. "plaso2graph/master/src/Entity"
	. "plaso2graph/master/src/Extractor"
	"runtime"
	"strings"
	"sync"
	"time"
	// "unsafe"
)

var (
	source        = flag.String("source", "data/output.json", "Source CSV File generated by plaso")
	outputDir     = flag.String("output", "output/", "Output Json File")
	extractorName = flag.String("extractor", "neo4j", "Type of Extractor to use. (default: neo4j, csv, json, xml)")
	verbose       = flag.Bool("verbose", false, "Verbose mode")
	username      = flag.String("username", "neo4j", "Username for Neo4j")
	password      = flag.Bool("password", false, "Prompt for password")
	url           = flag.String("url", "bolt://localhost:7687", "Url of Neo4j")
	computer      = flag.String("computer", "", "Defaulting 'computer' field to this value for artefacts that don't have it")
)

func compare(a string, b string) bool {
	return strings.Compare(a, b) == 0
}

func ValidateArgs() {
	// Check if source exists
	if _, err := os.Stat(*source); err != nil {
		fmt.Printf("Source file \"%s\" Does not exist\n", *source)
		log.Fatal()
	}

	if _, err := os.Stat(*outputDir); err == nil {
		fmt.Printf("Output file \"%s\" already exists exist\n", *outputDir)
	}

	if compare(*extractorName, "neo4j") && compare(*extractorName, "maltego") {
		fmt.Println("Extractor must be one from: neo4j, maltego.")
		fmt.Println("Extractor: ", *extractorName)
	}
}

func ProcessArgs() map[string]interface{} {
	ValidateArgs()

	args := make(map[string]interface{})
	args["source"] = *source
	args["output"] = *outputDir
	args["extractor"] = *extractorName
	args["verbose"] = *verbose
	args["username"] = *username
	args["url"] = *url
	args["computer"] = *computer

	if *password {
		var tmp string
		fmt.Print("Password: ")
		_, err := fmt.Scanln(&tmp)
		if err != nil {
			return nil
		}
		args["password"] = tmp
	} else {
		args["password"] = ""
	}
	return args
}

func containsString(strings []string, str string) bool {
	for _, s := range strings {
		if s == str {
			return true
		}
	}
	return false
}

// enumEventData Function to enumerate all the event data (for debug purposes)
/*
func enumEventData(data []PlasoLog) []string {
	var res []string

	for _, d := range data {
		if d.EvtxLog != nil {
			for _, dataName := range d.EvtxLog.EventData.Data {
				if !containsString(res, dataName.Name) {
					res = append(res, dataName.Name)
				}
			}
		}
	}
	return res
}
*/

// enumPlaso Function to enumerate all the plaso data (for debug purposes)
/*
func enumPlaso(data []PlasoLog) []string {
	var res []string
	for _, d := range data {
		if !containsString(res, d.DataType) {
			res = append(res, d.DataType)
		}
	}
	return res
}
*/

func GetToExtract(data []interface{}, batchSize int) []interface{} {
	var toExtract []interface{}

	for _, d := range data {
		switch d.(type) {
		case []Process:
			if len(d.([]Process)) > batchSize {
				toExtract = append(toExtract, d)
			}
			break
		case []File:
			if len(d.([]File)) > batchSize {
				toExtract = append(toExtract, d)
			}
			break
		case []User:
			if len(d.([]User)) > batchSize {
				toExtract = append(toExtract, d)
			}
			break
		case []Computer:
			if len(d.([]Computer)) > batchSize {
				toExtract = append(toExtract, d)
			}
			break
		case []ScheduledTask:
			if len(d.([]ScheduledTask)) > batchSize {
				toExtract = append(toExtract, d)
			}
			break
		case []WebHistory:
			if len(d.([]WebHistory)) > batchSize {
				toExtract = append(toExtract, d)
			}
			break

		}
	}
	return toExtract
}

func FlushData(data []interface{}, extracted []interface{}) []interface{} {
	for _, v := range extracted {
		switch v.(type) {
		case []Process:
			for i, v2 := range data {
				switch v2.(type) {
				case []Process:
					data[i] = *new([]Process)
					break
				}
			}
			break

		case []File:
			for i, v2 := range data {
				switch v2.(type) {
				case []File:
					data[i] = *new([]File)
					break
				}
			}
			break

		case []User:
			for i, v2 := range data {
				switch v2.(type) {
				case []User:
					data[i] = *new([]User)
					break
				}
			}
			break

		case []Computer:
			for i, v2 := range data {
				switch v2.(type) {
				case []Computer:
					data[i] = *new([]Computer)
					break
				}
			}
			break

		case []ScheduledTask:
			for i, v2 := range data {
				switch v2.(type) {
				case []ScheduledTask:
					data[i] = *new([]ScheduledTask)
					break
				}
			}
			break

		case []WebHistory:
			for i, v2 := range data {
				switch v2.(type) {
				case []WebHistory:
					data[i] = *new([]WebHistory)
					break
				}
			}
			break

		}
	}
	return data
}

func MergeEntities(data []interface{}) []interface{} {
	for i, v := range data {
		switch v.(type) {
		case []Process:
			data[i] = MergeProcesses(data[i].([]Process), 1000000)
			break
		}
	}
	return data
}

// printAlloc Function to Monitor Memory Usage
/*
func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d KB\n", m.Alloc/1024)
}
*/

func ProcessFile(path string, args map[string]interface{}) {
	var data = []interface{}{
		*new([]Process),
		*new([]ScriptBlock),
		*new([]File),
		*new([]User),
		*new([]Group),
		*new([]Computer),
		*new([]ScheduledTask),
		*new([]Service),
		*new([]Domain),
		*new([]WebHistory),
		*new([]Connection),
		*new([]Event),
		*new([]Registry),
	}

	if args["computer"].(string) != "" {
		data[5] = []Computer{{Name: args["computer"].(string), Domain: ""}}
	}
	var batchSize = 100000
	var extractTreshold = 1000
	var lines []PlasoLog

	// Variable used for debug and stats
	var totalLines int
	var dataTypes []string

	file, _ := os.Open(path)
	scanner := bufio.NewScanner(file)

	buf := make([]byte, 0, 128*1024)
	scanner.Buffer(buf, 2048*1024)
	var wg sync.WaitGroup
	for scanner.Scan() {
		line := ParseLine(scanner.Text())
		totalLines += 1
		if *verbose && !containsString(dataTypes, line.DataType) {
			dataTypes = append(dataTypes, line.DataType)
		}
		lines = append(lines, line)
		if len(lines) == batchSize {

			data = ParseEntities(data, lines, args)
			lines = *new([]PlasoLog)

			toExtract := GetToExtract(data, extractTreshold)

			//We Extract entities by batch of 1,000
			if toExtract != nil {
				//fmt.Println("Waiting for goroutines to finish...")
				//wg.Wait()
				//fmt.Println("Done")
				//fmt.Println("len(data) = ", len(data[1].([]File)))
				toExtract = MergeEntities(toExtract)
				//fmt.Println("Extracting entities")
				go func(toExtract []interface{}, args map[string]interface{}) {
					wg.Add(1)
					Extract(toExtract, args)
					wg.Done()
					//fmt.Println("Data extracted")
				}(toExtract, args)
				data = FlushData(data, toExtract)
				toExtract = nil
				runtime.GC()
				//printAlloc()
				//fmt.Println("Len: ", fmt.Sprint(data["file"]))
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	wg.Wait()
	data = ParseEntities(data, lines, args)
	lines = *new([]PlasoLog)

	wg.Wait()
	//We Extract the last entities
	data = MergeEntities(data)
	Extract(data, args)
	data = nil

	if *verbose {
		fmt.Println("Total lines: ", totalLines)
		fmt.Println("Data types: ", dataTypes)
	}

}

func main() {
	flag.Parse()
	args := ProcessArgs()
	args = InitializeExtractor(args)
	t := time.Now()
	fmt.Println("Starting extraction")
	ProcessFile(args["source"].(string), args)
	elapsed := time.Since(t)
	fmt.Println("Time elapsed: ", elapsed)
	fmt.Println("Done")

	fmt.Println("Starting Post-Processing")
	t = time.Now()
	PostProcessing(args)
	elapsed = time.Since(t)
	fmt.Println("Time elapsed: ", elapsed)
	fmt.Println("Done")
}

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	. "plaso2graph/master/src"
	. "plaso2graph/master/src/Entity"
	. "plaso2graph/master/src/Extractor"
	"strings"
	"time"
)

var (
	source         = flag.String("source", "data/evtx_all.json", "Source CSV File generated by plaso")
	output_dir     = flag.String("output", "output/output.json", "Output Json File")
	extractor_name = flag.String("extractor", "neo4j", "Type of Extractor to use. (default: neo4j, maltego)")
)

func HandleErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func compare(a string, b string) bool {
	return strings.Compare(a, b) == 0
}

func ValidateArgs() {
	// Check if source exists
	if _, err := os.Stat(*source); err != nil {
		fmt.Printf("Source file \"%s\" Does not exist\n", *source)
		log.Fatal()
	}

	if _, err := os.Stat(*output_dir); err == nil {
		fmt.Printf("Output file \"%s\" already exists exist\n", *output_dir)
	}

	if compare(*extractor_name, "neo4j") && compare(*extractor_name, "maltego") {
		fmt.Println("Extractor must be one from: neo4j, maltego.")
		fmt.Println("Extractor: ", *extractor_name)
	}
}

func containsString(strings []string, str string) bool {
	for _, s := range strings {
		if s == str {
			return true
		}
	}
	return false
}

func enumEventData(data []PlasoLog) []string {
	var res []string

	for _, d := range data {
		if d.EvtxLog != nil {
			for _, dataName := range d.EvtxLog.EventData.Data {
				if !containsString(res, dataName.Name) {
					res = append(res, dataName.Name)
				}
			}
		}
	}
	return res
}

func main() {
	flag.Parse()
	ValidateArgs()
	t := time.Now()
	dat := ParseFile(*source)
	elapsed := time.Since(t)
	log.Printf("Elapsed Time: %s", elapsed)
	size := len(dat)
	fmt.Printf("Line parsed : %d \n", size)

	/**
	names := enumEventData(dat)

	fmt.Println(fmt.Sprint(names))
	*/
	t = time.Now()
	processes := GetProcesses(dat)
	users := GetUsers(dat)
	elapsed = time.Since(t)
	log.Printf("Aggregate Data in : %s \n", elapsed)

	con := Neo4jConnect("admin", "admin", "bolt://localhost:7687")
	InsertProcesses(con, processes)

	InsertUsers(con, users)

}

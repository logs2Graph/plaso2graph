package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	. "plaso2graph/master/src/Entity"
	. "plaso2graph/master/src/Extractor"
	"runtime"
	"strings"
	"sync"
	"time"
	// "unsafe"
)

var (
	source         = flag.String("source", "data/output.json", "Source CSV File generated by plaso")
	output_dir     = flag.String("output", "output/", "Output Json File")
	extractor_name = flag.String("extractor", "neo4j", "Type of Extractor to use. (default: neo4j, csv, json, xml)")
	verbose        = flag.Bool("verbose", false, "Verbose mode")
	username       = flag.String("username", "neo4j", "Username for Neo4j")
	password       = flag.Bool("password", false, "Prompt for password")
	url            = flag.String("url", "bolt://localhost:7687", "Url of Neo4j")
)

func HandleErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func compare(a string, b string) bool {
	return strings.Compare(a, b) == 0
}

func ValidateArgs() {
	// Check if source exists
	if _, err := os.Stat(*source); err != nil {
		fmt.Printf("Source file \"%s\" Does not exist\n", *source)
		log.Fatal()
	}

	if _, err := os.Stat(*output_dir); err == nil {
		fmt.Printf("Output file \"%s\" already exists exist\n", *output_dir)
	}

	if compare(*extractor_name, "neo4j") && compare(*extractor_name, "maltego") {
		fmt.Println("Extractor must be one from: neo4j, maltego.")
		fmt.Println("Extractor: ", *extractor_name)
	}
}

func ProcessArgs() map[string]interface{} {
	ValidateArgs()

	args := make(map[string]interface{})
	args["source"] = *source
	args["output"] = *output_dir
	args["extractor"] = *extractor_name
	args["verbose"] = *verbose
	args["username"] = *username
	args["url"] = *url

	if *password {
		var tmp string
		fmt.Print("Password: ")
		fmt.Scanln(&tmp)
		args["password"] = tmp
	} else {
		args["password"] = ""
	}
	return args
}

func containsString(strings []string, str string) bool {
	for _, s := range strings {
		if s == str {
			return true
		}
	}
	return false
}

func enumEventData(data []PlasoLog) []string {
	var res []string

	for _, d := range data {
		if d.EvtxLog != nil {
			for _, dataName := range d.EvtxLog.EventData.Data {
				if !containsString(res, dataName.Name) {
					res = append(res, dataName.Name)
				}
			}
		}
	}
	return res
}

func enumPlaso(data []PlasoLog) []string {
	var res []string
	for _, d := range data {
		if !containsString(res, d.DataType) {
			res = append(res, d.DataType)
		}
	}
	return res
}

func GetToExtract(data []interface{}, batch_size int) []interface{} {
	var to_extract []interface{}

	for _, d := range data {
		switch d.(type) {
		case []Process:
			if len(d.([]Process)) > batch_size {
				to_extract = append(to_extract, d)
			}
			break
		case []File:
			if len(d.([]File)) > batch_size {
				to_extract = append(to_extract, d)
			}
			break
		case []User:
			if len(d.([]User)) > batch_size {
				to_extract = append(to_extract, d)
			}
			break
		case []Computer:
			if len(d.([]Computer)) > batch_size {
				to_extract = append(to_extract, d)
			}
			break
		case []ScheduledTask:
			if len(d.([]ScheduledTask)) > batch_size {
				to_extract = append(to_extract, d)
			}
			break
		case []WebHistory:
			if len(d.([]WebHistory)) > batch_size {
				to_extract = append(to_extract, d)
			}
			break

		}
	}
	return to_extract
}

func FlushData(data []interface{}, extracted []interface{}) []interface{} {
	for _, v := range extracted {
		switch v.(type) {
		case []Process:
			for i, v2 := range data {
				switch v2.(type) {
				case []Process:
					data[i] = *new([]Process)
					break
				}
			}
			break

		case []File:
			for i, v2 := range data {
				switch v2.(type) {
				case []File:
					data[i] = *new([]File)
					break
				}
			}
			break

		case []User:
			for i, v2 := range data {
				switch v2.(type) {
				case []User:
					data[i] = *new([]User)
					break
				}
			}
			break

		case []Computer:
			for i, v2 := range data {
				switch v2.(type) {
				case []Computer:
					data[i] = *new([]Computer)
					break
				}
			}
			break

		case []ScheduledTask:
			for i, v2 := range data {
				switch v2.(type) {
				case []ScheduledTask:
					data[i] = *new([]ScheduledTask)
					break
				}
			}
			break

		case []WebHistory:
			for i, v2 := range data {
				switch v2.(type) {
				case []WebHistory:
					data[i] = *new([]WebHistory)
					break
				}
			}
			break

		}
	}
	return data
}

func MergeEntities(data []interface{}) []interface{} {
	for i, v := range data {
		switch v.(type) {
		case []Process:
			data[i] = MergeProcesses(data[i].([]Process), 1000000)
			break
		}
	}
	return data
}

func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d KB\n", m.Alloc/1024)
}

func ProcessFile(path string, args map[string]interface{}) {
	var data = []interface{}{
		*new([]Process),
		*new([]ScriptBlock),
		*new([]File),
		*new([]User),
		*new([]Group),
		*new([]Computer),
		*new([]ScheduledTask),
		*new([]Service),
		*new([]Domain),
		*new([]WebHistory),
		*new([]Connection),
		*new([]Event),
		*new([]Registry),
	}

	var batch_size = 100000
	var extract_treshold = 1000
	var lines []PlasoLog

	// Variable used for debug and stats
	var total_lines int
	var data_types []string

	file, _ := os.Open(path)
	scanner := bufio.NewScanner(file)

	buf := make([]byte, 0, 128*1024)
	scanner.Buffer(buf, 2048*1024)
	var wg sync.WaitGroup
	for scanner.Scan() {
		line := ParseLine(scanner.Text())
		total_lines += 1
		if *verbose && !containsString(data_types, line.DataType) {
			data_types = append(data_types, line.DataType)
		}
		lines = append(lines, line)
		if len(lines) == batch_size {

			data = ParseEntities(data, lines)
			lines = *new([]PlasoLog)

			toExtract := GetToExtract(data, extract_treshold)

			//We Extract entities by batch of 1,000
			if toExtract != nil {
				//fmt.Println("Waiting for goroutines to finish...")
				//wg.Wait()
				//fmt.Println("Done")
				//fmt.Println("len(data) = ", len(data[1].([]File)))
				toExtract = MergeEntities(toExtract)
				//fmt.Println("Extracting entities")
				go func(toExtract []interface{}, args map[string]interface{}) {
					wg.Add(1)
					Extract(toExtract, args)
					wg.Done()
					//fmt.Println("Data extracted")
				}(toExtract, args)
				data = FlushData(data, toExtract)
				toExtract = nil
				runtime.GC()
				//printAlloc()
				//fmt.Println("Len: ", fmt.Sprint(data["file"]))
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	wg.Wait()
	data = ParseEntities(data, lines)
	lines = *new([]PlasoLog)

	wg.Wait()
	//We Extract the last entities
	data = MergeEntities(data)
	Extract(data, args)
	data = nil

	if *verbose {
		fmt.Println("Total lines: ", total_lines)
		fmt.Println("Data types: ", data_types)
	}

}

func main() {
	flag.Parse()
	args := ProcessArgs()
	args = InitializeExtractor(args)
	t := time.Now()
	fmt.Println("Starting extraction")
	ProcessFile(args["source"].(string), args)
	elapsed := time.Since(t)
	fmt.Println("Time elapsed: ", elapsed)
	fmt.Println("Done")

	fmt.Println("Starting Post-Processing")
	t = time.Now()
	PostProcessing(args)
	elapsed = time.Since(t)
	fmt.Println("Time elapsed: ", elapsed)
	fmt.Println("Done")
}
